"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[90160],{8239:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>d});var i=t(74848),r=t(28453);const a={title:"Advanced Charting",sidebar_position:4,description:"Learn how to integrate your own backend with OpenBB Terminal Pro using the cookie-cutter or language-agnostic API approaches, with illustrative guides and principles for handling widget.json files, APIs, interfaces, Python, FastAPI, and more.",keywords:["widgets.json","OpenBB API","Endpoint integration","widget configuration","Language-Agnostic API","API implementation","Python","FastAPI","Terminal Pro widgets","Widget definitions"]},o="Advanced Charting Widget",s={id:"terminal/custom-backend/Widgets/advanced_charting",title:"Advanced Charting",description:"Learn how to integrate your own backend with OpenBB Terminal Pro using the cookie-cutter or language-agnostic API approaches, with illustrative guides and principles for handling widget.json files, APIs, interfaces, Python, FastAPI, and more.",source:"@site/content/terminal/custom-backend/Widgets/advanced_charting.md",sourceDirName:"terminal/custom-backend/Widgets",slug:"/terminal/custom-backend/Widgets/advanced_charting",permalink:"/terminal/custom-backend/Widgets/advanced_charting",draft:!1,unlisted:!1,editUrl:"https://github.com/OpenBB-finance/openbb-docs/edit/main/content/terminal/custom-backend/Widgets/advanced_charting.md",tags:[],version:"current",lastUpdatedBy:"Andrew",lastUpdatedAt:1742312264e3,sidebarPosition:4,frontMatter:{title:"Advanced Charting",sidebar_position:4,description:"Learn how to integrate your own backend with OpenBB Terminal Pro using the cookie-cutter or language-agnostic API approaches, with illustrative guides and principles for handling widget.json files, APIs, interfaces, Python, FastAPI, and more.",keywords:["widgets.json","OpenBB API","Endpoint integration","widget configuration","Language-Agnostic API","API implementation","Python","FastAPI","Terminal Pro widgets","Widget definitions"]},sidebar:"tutorialSidebar",previous:{title:"Plotly Chart",permalink:"/terminal/custom-backend/Widgets/chart/plotly"},next:{title:"Live Grid",permalink:"/terminal/custom-backend/Widgets/live_grid"}},l={},d=[{value:"Step 1: Set Up Your Project",id:"step-1-set-up-your-project",level:2},{value:"Step 2: Create the Charting Endpoints",id:"step-2-create-the-charting-endpoints",level:2},{value:"Step 3: Create the widgets.json File",id:"step-3-create-the-widgetsjson-file",level:2},{value:"Step 4: Add to OpenBB Pro",id:"step-4-add-to-openbb-pro",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"advanced-charting-widget",children:"Advanced Charting Widget"}),"\n",(0,i.jsx)(n.p,{children:"This guide will walk you through the process of creating an advanced charting widget for OpenBB Terminal Pro using TradingView UDF (Universal Data Feed) protocol with Kraken cryptocurrency data. By the end of this guide, you will have a working advanced charting widget that can display interactive price charts."}),"\n",(0,i.jsx)(n.h2,{id:"step-1-set-up-your-project",children:"Step 1: Set Up Your Project"}),"\n",(0,i.jsx)(n.p,{children:"To get started, create the main application file and the widget configuration file. You will need these files:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"main.py"}),": This file will contain your FastAPI application code."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"widgets.json"}),": This file will define the configuration for your widget."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The backend will use the same FastAPI setup and structure as described in the ",(0,i.jsx)(n.a,{href:"/terminal/custom-backend/",children:"Custom Backend"})," page."]}),"\n",(0,i.jsx)(n.h2,{id:"step-2-create-the-charting-endpoints",children:"Step 2: Create the Charting Endpoints"}),"\n",(0,i.jsxs)(n.p,{children:["Edit the ",(0,i.jsx)(n.code,{children:"main.py"})," file and add the following code. This sets up a FastAPI application that implements the TradingView UDF protocol to connect with Kraken's cryptocurrency market data:"]}),"\n",(0,i.jsx)(n.p,{children:"Note : This is a TradingView UDF (Universal Data Feed) protocol, it requires implementing several key endpoints:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Configuration (/udf/config): Provides information about supported features, resolutions, and exchanges"}),"\n",(0,i.jsx)(n.li,{children:"Symbol Search (/udf/search): Allows searching for available trading pairs"}),"\n",(0,i.jsx)(n.li,{children:"Symbol Info (/udf/symbols): Returns detailed information about a specific symbol"}),"\n",(0,i.jsx)(n.li,{children:"Historical Data (/udf/history): Retrieves OHLCV (Open, High, Low, Close, Volume) data for charting"}),"\n",(0,i.jsx)(n.li,{children:"Server Time (/udf/time): Provides the current server time for synchronization"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The implementation also maps TradingView's resolution codes to Kraken's interval parameters:"}),"\n",(0,i.jsx)(n.p,{children:'"1" \u2192 1 minute\n"60" \u2192 1 hour\n"D" \u2192 1 day\n"W" \u2192 1 week'}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)("summary",{mdxType:"summary",children:"Click to expand/collapse code"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from fastapi import FastAPI, Query, HTTPException\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom typing import List, Dict, Any, Optional, Union\nfrom pydantic import BaseModel\nimport httpx\nimport time\nimport logging\nfrom enum import Enum\nimport json\nfrom pathlib import Path\nfrom fastapi.responses import JSONResponse\n\napp = FastAPI(title="TradingView UDF Kraken API")\n\n# Add CORS middleware\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=["*"],\n    allow_credentials=True,\n    allow_methods=["*"],\n    allow_headers=["*"],\n)\n\n# Kraken API base URL\nKRAKEN_API_BASE = "https://api.kraken.com"\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# Models\nclass UDFSearchResult(BaseModel):\n    symbol: str\n    full_name: str\n    description: str\n    exchange: str\n    ticker: str\n    type: str\n\nclass UDFSymbolInfo(BaseModel):\n    name: str\n    ticker: str\n    description: str\n    type: str\n    exchange: str\n    listed_exchange: str\n    timezone: str\n    session: str\n    minmov: int\n    pricescale: int\n    has_intraday: bool\n    has_daily: bool\n    has_weekly_and_monthly: bool\n    supported_resolutions: List[str]\n    currency_code: str\n    original_currency_code: str\n    volume_precision: int\n\nclass UDFBar(BaseModel):\n    s: str\n    errmsg: Optional[str] = None\n    t: Optional[List[int]] = None\n    c: Optional[List[float]] = None\n    o: Optional[List[float]] = None\n    h: Optional[List[float]] = None\n    l: Optional[List[float]] = None\n    v: Optional[List[float]] = None\n    nextTime: Optional[int] = None\n\nclass ResolutionEnum(str, Enum):\n    ONE_MINUTE = "1"\n    THREE_MINUTES = "3"\n    FIVE_MINUTES = "5"\n    FIFTEEN_MINUTES = "15"\n    THIRTY_MINUTES = "30"\n    ONE_HOUR = "60"\n    TWO_HOURS = "120"\n    FOUR_HOURS = "240"\n    SIX_HOURS = "360"\n    EIGHT_HOURS = "480"\n    TWELVE_HOURS = "720"\n    ONE_DAY = "D"\n    THREE_DAYS = "3D"\n    ONE_WEEK = "W"\n    ONE_MONTH = "M"\n\n# Helper functions\ndef resolution_to_interval(resolution: str) -> str:\n    resolution_map = {\n        "1": "1",\n        "3": "3",\n        "5": "5",\n        "15": "15",\n        "30": "30",\n        "60": "60",\n        "120": "120",\n        "240": "240",\n        "360": "360",\n        "480": "480",\n        "720": "720",\n        "D": "1440",\n        "1D": "1440",\n        "3D": "4320",\n        "W": "10080",\n        "1W": "10080",\n        "M": "21600",\n        "1M": "21600",\n    }\n    return resolution_map.get(resolution, "60")\n\nasync def fetch_kraken_data(endpoint: str, params: Dict[str, Any] = None) -> Any:\n    url = f"{KRAKEN_API_BASE}{endpoint}"\n    \n    try:\n        async with httpx.AsyncClient() as client:\n            response = await client.get(url, params=params, timeout=10.0)\n            response.raise_for_status()\n            data = response.json()\n            \n            # Kraken API returns errors in a specific format\n            if data.get("error") and len(data["error"]) > 0:\n                logger.error(f"Kraken API error: {data[\'error\']}")\n                raise HTTPException(status_code=500, detail=f"Kraken API error: {data[\'error\']}")\n                \n            return data\n    except httpx.HTTPError as e:\n        logger.error(f"Error fetching data from Kraken API: {e}")\n        raise HTTPException(status_code=500, detail=f"Error fetching data from Kraken: {str(e)}")\n    \n@app.get("/")\nasync def root():\n    return "OpenBB Workspace Backend example for bringing your own data to charting tradingview"\n\n@app.get("/widgets.json")\ndef get_widgets():\n    """Widgets configuration file for the OpenBB Custom Backend"""\n    return JSONResponse(\n        content=json.load((Path(__file__).parent.resolve() / "widgets.json").open())\n    )\n\n# UDF API endpoints\n@app.get("/udf/config")\nasync def get_config():\n    config = {\n        "supported_resolutions": ["1", "3", "5", "15", "30", "60", "120", "240", "360", "480", "720", "D", "3D", "W", "M"],\n        "supports_group_request": False,\n        "supports_marks": False,\n        "supports_search": True,\n        "supports_timescale_marks": False,\n        "supports_time": True,\n        "exchanges": [\n            {"value": "", "name": "All Exchanges", "desc": ""},\n            {"value": "KRAKEN", "name": "Kraken", "desc": "Kraken Exchange"}\n        ],\n        "symbols_types": [\n            {"name": "All types", "value": ""},\n            {"name": "Crypto", "value": "crypto"}\n        ]\n    }\n    return config\n\n@app.get("/udf/search", response_model=List[UDFSearchResult])\nasync def search_symbols(\n    query: str = Query("", description="Search query"),\n    limit: int = Query(30, description="Limit of results")\n):\n    try:\n        # Get asset pairs from Kraken\n        asset_pairs = await fetch_kraken_data("/0/public/AssetPairs")\n        \n        filtered_symbols = []\n        for pair_name, pair_info in asset_pairs.get("result", {}).items():\n            # Skip darkpool pairs\n            if pair_name.startswith("."):\n                continue\n                \n            base_asset = pair_info.get("base", "")\n            quote_asset = pair_info.get("quote", "")\n            wsname = pair_info.get("wsname", pair_name)\n            \n            if (query.lower() in pair_name.lower() or \n                query.lower() in base_asset.lower() or \n                query.lower() in quote_asset.lower()):\n                filtered_symbols.append({\n                    "symbol": pair_name,\n                    "wsname": wsname,\n                    "base": base_asset,\n                    "quote": quote_asset,\n                    "altname": pair_info.get("altname", pair_name)\n                })\n                \n            if len(filtered_symbols) >= limit:\n                break\n        \n        results = [\n            UDFSearchResult(\n                symbol=symbol["symbol"],\n                full_name=f"KRAKEN:{symbol[\'symbol\']}",\n                description=f"{symbol[\'base\']}/{symbol[\'quote\']}",\n                exchange="KRAKEN",\n                ticker=symbol["symbol"],\n                type="crypto"\n            )\n            for symbol in filtered_symbols\n        ]\n        \n        return results\n    except Exception as e:\n        logger.error(f"Error in symbol search: {e}")\n        return []\n\n@app.get("/udf/symbols")\nasync def get_symbol_info(symbol: str = Query(..., description="Symbol to get info for")):\n    clean_symbol = symbol.split(":")[-1] if ":" in symbol else symbol\n    \n    try:\n        # Get asset pairs from Kraken\n        asset_pairs = await fetch_kraken_data("/0/public/AssetPairs")\n        \n        if clean_symbol not in asset_pairs.get("result", {}):\n            return {"s": "error", "errmsg": "Symbol not found"}\n            \n        symbol_info = asset_pairs["result"][clean_symbol]\n        \n        # Determine price scale based on pair decimals\n        pair_decimals = symbol_info.get("pair_decimals", 8)\n        price_scale = 10 ** pair_decimals\n        \n        result = {\n            "name": symbol_info.get("wsname", clean_symbol),\n            "ticker": clean_symbol,\n            "description": f"{symbol_info.get(\'base\', \'\')}/{symbol_info.get(\'quote\', \'\')}",\n            "type": "crypto",\n            "exchange": "KRAKEN",\n            "listed_exchange": "KRAKEN",\n            "timezone": "Etc/UTC",\n            "session": "24x7",\n            "minmov": 1,\n            "pricescale": price_scale,\n            "has_intraday": True,\n            "has_daily": True,\n            "has_weekly_and_monthly": True,\n            "supported_resolutions": ["1", "3", "5", "15", "30", "60", "120", "240", "360", "480", "720", "D", "3D", "W", "M"],\n            "currency_code": symbol_info.get("quote", ""),\n            "original_currency_code": symbol_info.get("quote", ""),\n            "volume_precision": symbol_info.get("lot_decimals", 8)\n        }\n        \n        return result\n    except Exception as e:\n        logger.error(f"Error in symbol info: {e}")\n        return {"s": "error", "errmsg": "Failed to fetch symbol info"}\n\n@app.get("/udf/history")\nasync def get_history(\n    symbol: str = Query(..., description="Symbol"),\n    resolution: str = Query(..., description="Resolution"),\n    from_time: int = Query(..., alias="from", description="From timestamp"),\n    to_time: int = Query(..., alias="to", description="To timestamp"),\n    countback: Optional[int] = Query(0, description="Count back")\n):\n    clean_symbol = symbol.split(":")[-1] if ":" in symbol else symbol\n    interval = resolution_to_interval(resolution)\n    \n    try:\n        params = {\n            "pair": clean_symbol,\n            "interval": interval\n        }\n        \n        # Kraken OHLC endpoint accepts \'since\' parameter in seconds\n        if from_time > 0:\n            params["since"] = str(from_time)\n            \n        # Kraken doesn\'t have a direct \'to\' parameter or \'countback\'\n        # We\'ll fetch data and filter it on our side\n        \n        ohlc_data = await fetch_kraken_data("/0/public/OHLC", params)\n        \n        if not ohlc_data or "result" not in ohlc_data:\n            return {"s": "no_data"}\n            \n        # Kraken returns data in format {pair_name: [[time, open, high, low, close, vwap, volume, count], ...], last: timestamp}\n        klines = ohlc_data["result"].get(clean_symbol, [])\n        \n        # Filter by time range\n        filtered_klines = [\n            kline for kline in klines \n            if from_time <= kline[0] <= to_time\n        ]\n        \n        if not filtered_klines:\n            return {"s": "no_data"}\n            \n        # Apply countback if specified\n        if countback > 0 and len(filtered_klines) > countback:\n            filtered_klines = filtered_klines[-countback:]\n        \n        result = {\n            "s": "ok",\n            "t": [int(kline[0]) for kline in filtered_klines],       # Time\n            "o": [float(kline[1]) for kline in filtered_klines],     # Open\n            "h": [float(kline[2]) for kline in filtered_klines],     # High\n            "l": [float(kline[3]) for kline in filtered_klines],     # Low\n            "c": [float(kline[4]) for kline in filtered_klines],     # Close\n            "v": [float(kline[6]) for kline in filtered_klines]      # Volume\n        }\n        \n        return result\n    except Exception as e:\n        logger.error(f"Error in history data: {e}")\n        return {"s": "error", "errmsg": f"Failed to fetch history data: {str(e)}"}\n\n@app.get("/udf/time")\nasync def get_server_time():\n    try:\n        time_data = await fetch_kraken_data("/0/public/Time")\n        return int(time_data["result"]["unixtime"])  # Kraken returns time in seconds\n    except Exception as e:\n        logger.error(f"Error in server time: {e}")\n        return int(time.time())  # Return current time as fallback\n\nif __name__ == "__main__":\n    import uvicorn\n    uvicorn.run(app, host="0.0.0.0", port=5050)\n'})})]}),"\n",(0,i.jsx)(n.h2,{id:"step-3-create-the-widgetsjson-file",children:"Step 3: Create the widgets.json File"}),"\n",(0,i.jsxs)(n.p,{children:["Edit the ",(0,i.jsx)(n.code,{children:"widgets.json"})," file and add the following JSON data. This configuration defines the widget's properties and how it should be displayed:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n    "udf_kraken": {\n        "name": "Advanced Charting - Kraken",\n        "description": "Advanced charting for Kraken, historical data from any Kraken asset",\n        "category": "Finance",\n        "type": "advanced_charting",\n        "endpoint": "/udf",\n        "gridData": {\n            "w": 20,\n            "h": 20\n        },\n        "data": {\n            "defaultSymbol": "XBTUSDC",\n            "updateFrequency" : 60000\n        }\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"updateFrequency"})," is the frequency in milliseconds that the chart widget will update the data. Default is 60000 (1 minute)."]}),"\n",(0,i.jsx)(n.h2,{id:"step-4-add-to-openbb-pro",children:"Step 4: Add to OpenBB Pro"}),"\n",(0,i.jsxs)(n.p,{children:["Navigate to OpenBB Pro Data Connectors and add your backend by clicking on the + Add Data button in the top right corner. Select Custom Backend and fill in the details. Your URL will be ",(0,i.jsx)(n.a,{href:"http://localhost:5050",children:"http://localhost:5050"}),"."]}),"\n",(0,i.jsx)("img",{className:"pro-border-gradient",width:"600",alt:"advanced-charting",src:"https://openbb-assets.s3.us-east-1.amazonaws.com/docs/pro/advanced_charting.png"}),"\n",(0,i.jsxs)(n.p,{children:["Once you have added your backend, you can find the widget with the name ",(0,i.jsx)(n.code,{children:"Advanced Charting - Kraken"}),". The widget will display interactive price charts for cryptocurrency pairs available on Kraken."]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var i=t(96540);const r={},a=i.createContext(r);function o(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);